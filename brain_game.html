<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrainSpeed Trainer</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #3498db;
            --danger: #e74c3c;
            --success: #2ecc71;
            --bg: #ecf0f1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* --- UI & Navigation --- */
        header {
            width: 100%;
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .nav-buttons {
            margin-top: 10px;
        }

        button {
            padding: 10px 20px;
            margin: 0 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }

        .btn-game { background: var(--accent); color: white; }
        .btn-game:hover { transform: translateY(-2px); box-shadow: 0 4px 0 #2980b9; }

        /* --- HUD --- */
        #hud {
            display: flex;
            justify-content: space-between;
            width: 80%;
            max-width: 800px;
            margin: 10px 0;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary);
        }

        /* --- Game Area --- */
        #game-container {
            position: relative;
            width: 90%;
            max-width: 800px;
            height: 400px;
            background: white;
            border: 4px solid var(--primary);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
        }

        /* Moving Questions */
        .question-bubble {
            position: absolute;
            left: -150px; /* Start off screen */
            top: 50%;
            background: var(--accent);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 1.2rem;
            white-space: nowrap;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        .question-bubble.danger { background: var(--danger); }

        /* Connect the Dots specific */
        .dot {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* --- Controls --- */
        #input-area {
            margin-top: 20px;
            display: none; /* Hidden for dot game */
        }

        input[type="text"], input[type="number"] {
            padding: 15px;
            font-size: 1.5rem;
            width: 300px;
            text-align: center;
            border: 2px solid var(--primary);
            border-radius: 10px;
            outline: none;
        }

        input:focus { border-color: var(--accent); }

        /* Overlays */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .hidden { display: none !important; }

    </style>
</head>
<body>

<header>
    <h1>ðŸ§  Brain Speed Trainer</h1>
    <div class="nav-buttons">
        <button class="btn-game" onclick="gameManager.switchGame('math')">Math Master</button>
        <button class="btn-game" onclick="gameManager.switchGame('grammar')">Grammar Dash</button>
        <button class="btn-game" onclick="gameManager.switchGame('dots')">Connect Dots</button>
    </div>
</header>

<div id="hud">
    <span>Level: <span id="level-display">1</span></span>
    <span>Score: <span id="score-display">0</span></span>
    <span>Lives: <span id="lives-display">5</span></span>
</div>

<div id="game-container">
    <div id="overlay">
        <h2 id="overlay-title">Select a Game</h2>
        <p id="overlay-msg">Click a button above to start brain training.</p>
        <button class="btn-game hidden" id="start-btn" onclick="gameManager.startGame()">Start Level</button>
    </div>
</div>

<div id="input-area">
    <input type="text" id="player-input" placeholder="Type answer here..." autocomplete="off">
</div>

<script>
/**
 * BRAIN TRAINER ENGINE
 */

const CONFIG = {
    levels: 50,
    questionsPerLevel: 10,
    baseSpeed: 1.5, // Pixels per frame
};

class GameManager {
    constructor() {
        this.score = 0;
        this.level = 1;
        this.lives = 5;
        this.currentGameType = null;
        this.isPlaying = false;
        this.questionsAnsweredInLevel = 0;
        
        // Arrays to hold active elements
        this.activeEntities = []; 
        this.spawnInterval = null;
        this.gameLoopId = null;

        // HTML Elements
        this.container = document.getElementById('game-container');
        this.input = document.getElementById('player-input');
        this.overlay = document.getElementById('overlay');
        this.startBtn = document.getElementById('start-btn');
    }

    switchGame(type) {
        this.currentGameType = type;
        this.resetStats();
        
        const title = document.getElementById('overlay-title');
        const msg = document.getElementById('overlay-msg');
        
        this.overlay.classList.remove('hidden');
        this.startBtn.classList.remove('hidden');
        
        if(type === 'math') {
            title.innerText = "Math Master";
            msg.innerText = "Solve the equations before they hit the right wall!";
            document.getElementById('input-area').style.display = 'block';
        } else if (type === 'grammar') {
            title.innerText = "Grammar Dash";
            msg.innerText = "Fill in the blanks or fix the error!";
            document.getElementById('input-area').style.display = 'block';
        } else if (type === 'dots') {
            title.innerText = "Connect the Dots";
            msg.innerText = "Click numbers 1, 2, 3... in order as fast as possible!";
            document.getElementById('input-area').style.display = 'none';
        }
    }

    resetStats() {
        this.score = 0;
        this.level = 1;
        this.lives = 5;
        this.questionsAnsweredInLevel = 0;
        this.updateHUD();
    }

    updateHUD() {
        document.getElementById('level-display').innerText = this.level;
        document.getElementById('score-display').innerText = this.score;
        document.getElementById('lives-display').innerText = this.lives;
    }

    startGame() {
        this.isPlaying = true;
        this.overlay.classList.add('hidden');
        this.input.value = '';
        this.input.focus();
        this.activeEntities = [];
        this.container.innerHTML = '<div id="overlay" class="hidden"></div>'; // Clear container but keep overlay structure
        this.container.appendChild(this.overlay);

        if (this.currentGameType === 'dots') {
            this.startDotGame();
        } else {
            this.startScrollingGame();
        }
    }

    stopGame(reason) {
        this.isPlaying = false;
        clearInterval(this.spawnInterval);
        cancelAnimationFrame(this.gameLoopId);
        
        const title = document.getElementById('overlay-title');
        const msg = document.getElementById('overlay-msg');
        
        this.overlay.classList.remove('hidden');
        this.startBtn.innerText = "Try Again";
        
        if(reason === 'gameover') {
            title.innerText = "Game Over";
            msg.innerText = `You reached Level ${this.level} with ${this.score} points.`;
            this.resetStats();
        } else if (reason === 'levelup') {
            title.innerText = "Level Complete!";
            msg.innerText = `Get ready for Level ${this.level}...`;
            this.startBtn.innerText = "Next Level";
        }
    }

    levelUp() {
        if(this.level >= CONFIG.levels) {
            alert("You have beaten the game! Amazing!");
            this.resetStats();
            return;
        }
        this.level++;
        this.lives++; // Bonus life
        this.questionsAnsweredInLevel = 0;
        this.stopGame('levelup');
    }

    // --- LOGIC FOR SCROLLING GAMES (MATH & GRAMMAR) ---

    startScrollingGame() {
        // 1. Start Game Loop (Movement)
        const loop = () => {
            if(!this.isPlaying) return;
            this.updatePositions();
            this.gameLoopId = requestAnimationFrame(loop);
        };
        this.gameLoopId = requestAnimationFrame(loop);

        // 2. Start Spawner
        // Spawn rate gets faster as levels go up
        let spawnRate = 3000 - (this.level * 40); 
        if (spawnRate < 800) spawnRate = 800; // Cap max spawn speed

        this.spawnInterval = setInterval(() => {
            this.spawnQuestion();
        }, spawnRate);
    }

    spawnQuestion() {
        // Don't spawn if we hit the limit for this level
        if(this.questionsAnsweredInLevel >= CONFIG.questionsPerLevel) return;

        let content = {};
        if (this.currentGameType === 'math') {
            content = this.generateMathQuestion();
        } else {
            content = this.generateGrammarQuestion();
        }

        const el = document.createElement('div');
        el.className = 'question-bubble';
        el.innerText = content.text;
        el.dataset.answer = content.answer; // Store answer in data attribute
        
        // Random Vertical Position (avoid overlapping top/bottom)
        const maxTop = this.container.clientHeight - 60;
        el.style.top = Math.max(10, Math.random() * maxTop) + 'px';
        
        // Start Position (Left)
        el.style.left = '0px';

        this.container.appendChild(el);
        this.activeEntities.push({
            el: el,
            x: 0,
            speed: CONFIG.baseSpeed + (this.level * 0.2), // Speed increases by level
            answer: content.answer.toString().toLowerCase()
        });
    }

    updatePositions() {
        const containerWidth = this.container.clientWidth;

        this.activeEntities.forEach((entity, index) => {
            // Move Logic
            entity.x += entity.speed;
            entity.el.style.left = entity.x + 'px';

            // Check Collision (Right Side)
            if (entity.x > containerWidth - 100) {
                this.handleMiss(index);
            }
        });
    }

    handleMiss(index) {
        // Remove from DOM and Array
        const entity = this.activeEntities[index];
        if (entity && entity.el) {
            entity.el.remove();
            this.activeEntities.splice(index, 1);
            
            // Penalty
            this.lives--;
            this.updateHUD();
            
            // Visual feedback
            this.container.style.backgroundColor = '#ffcccc';
            setTimeout(() => this.container.style.backgroundColor = 'white', 200);

            if(this.lives <= 0) {
                this.stopGame('gameover');
            }
        }
    }

    checkInput(val) {
        const cleanVal = val.toLowerCase().trim();
        // Check active entities to see if any match the input
        // We iterate backwards to prioritize the oldest question (closest to right) usually, 
        // but finding ANY match is usually good enough for this style.
        
        const matchIndex = this.activeEntities.findIndex(e => e.answer === cleanVal);

        if (matchIndex !== -1) {
            // Correct Answer!
            const entity = this.activeEntities[matchIndex];
            entity.el.style.background = '#2ecc71';
            entity.el.style.transform = 'scale(1.5)';
            
            setTimeout(() => entity.el.remove(), 100);
            this.activeEntities.splice(matchIndex, 1);

            this.score += 10 * this.level;
            this.questionsAnsweredInLevel++;
            this.input.value = ''; // Clear input
            this.updateHUD();

            // Check Level Complete
            if(this.activeEntities.length === 0 && this.questionsAnsweredInLevel >= CONFIG.questionsPerLevel) {
                this.levelUp();
            }
        }
    }

    // --- CONTENT GENERATORS ---

    generateMathQuestion() {
        // Difficulty scaling
        const limit = this.level * 10;
        const types = ['+', '-', '*'];
        if (this.level > 10) types.push('/');

        const op = types[Math.floor(Math.random() * types.length)];
        let a, b, ans;

        switch(op) {
            case '+':
                a = Math.floor(Math.random() * limit);
                b = Math.floor(Math.random() * limit);
                ans = a + b;
                break;
            case '-':
                a = Math.floor(Math.random() * limit) + limit; // ensure positive
                b = Math.floor(Math.random() * limit);
                ans = a - b;
                break;
            case '*':
                a = Math.floor(Math.random() * (this.level + 2));
                b = Math.floor(Math.random() * 10);
                ans = a * b;
                break;
            case '/':
                b = Math.floor(Math.random() * 10) + 1;
                ans = Math.floor(Math.random() * 10) + 1; // answer
                a = b * ans; // ensure clean division
                break;
        }

        return { text: `${a} ${op} ${b}`, answer: ans };
    }

    generateGrammarQuestion() {
        // A mini database of grammar/vocab questions
        // In a real app, this would be much larger or fetched from an API
        const qBank = [
            { t: "Cat (plural)", a: "cats" },
            { t: "Past of 'Go'", a: "went" },
            { t: "Opposite of 'Up'", a: "down" },
            { t: "He ___ tall (is/am)", a: "is" },
            { t: "They ___ playing (is/are)", a: "are" },
            { t: "Sun is ___ (hot/cold)", a: "hot" },
            { t: "Opposite of 'Day'", a: "night" },
            { t: "Child (plural)", a: "children" },
            { t: "Past of 'Run'", a: "ran" },
            { t: "Mouse (plural)", a: "mice" }
        ];
        
        // Pick random, maybe shuffle based on level in future
        const q = qBank[Math.floor(Math.random() * qBank.length)];
        return { text: q.t, answer: q.a };
    }


    // --- DOTS GAME LOGIC (Canvas-like DOM implementation) ---

    startDotGame() {
        // Clear board
        this.activeEntities = []; // We will use this to store next number
        const dotsCount = 5 + Math.floor(this.level / 2); // More dots per level
        
        let currentTarget = 1;

        for (let i = 1; i <= dotsCount; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot';
            dot.innerText = i;
            
            // Random Position constrained to container
            const maxX = this.container.clientWidth - 50;
            const maxY = this.container.clientHeight - 50;
            
            dot.style.left = Math.floor(Math.random() * maxX) + 'px';
            dot.style.top = Math.floor(Math.random() * maxY) + 'px';

            dot.onclick = () => {
                if(parseInt(dot.innerText) === currentTarget) {
                    dot.style.background = '#2ecc71'; // Green
                    dot.style.pointerEvents = 'none'; // Disable click
                    dot.style.opacity = '0.5';
                    currentTarget++;
                    this.score += 5;
                    this.updateHUD();

                    if(currentTarget > dotsCount) {
                        this.levelUp();
                    }
                } else {
                    // Penalty for wrong click
                    this.score -= 5;
                    this.updateHUD();
                    dot.style.background = '#e74c3c'; // Red flash
                    setTimeout(()=> dot.style.background = '#2c3e50', 200);
                }
            };

            this.container.appendChild(dot);
        }
    }
}

// Initialize Game
const gameManager = new GameManager();

// Event Listener for Input
document.getElementById('player-input').addEventListener('input', (e) => {
    if(gameManager.isPlaying) {
        gameManager.checkInput(e.target.value);
    }
});

// Prevent form submit if enter is pressed (just clear box if needed)
document.getElementById('player-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.target.value = '';
    }
});

</script>

</body>
</html>